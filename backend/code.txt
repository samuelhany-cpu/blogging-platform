The following is a digest of the repository "backend".
This digest is designed to be easily parsed by Large Language Models.

--- SUMMARY ---
Repository: backend
Files Analyzed: 25
Total Text Size: 26.26 KB
Estimated Tokens (text only): ~6,906

--- DIRECTORY STRUCTURE ---
backend/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ db.js
â”‚   â””â”€â”€ jwt.js
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ articleController.js
â”‚   â”œâ”€â”€ authController.js
â”‚   â”œâ”€â”€ commentController.js
â”‚   â””â”€â”€ userController.js
â”œâ”€â”€ middlewares/
â”‚   â”œâ”€â”€ auth.js
â”‚   â””â”€â”€ errorHandler.js
â”œâ”€â”€ models/
â”‚   â””â”€â”€ Article.js
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ articleRoutes.js
â”‚   â”œâ”€â”€ authRoutes.js
â”‚   â”œâ”€â”€ commentRoutes.js
â”‚   â””â”€â”€ userRoutes.js
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ authMiddleware.test.js
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ setup.js
â”‚   â”‚   â”œâ”€â”€ testLoginHelper.js
â”‚   â”‚   â””â”€â”€ testUtils.js
â”‚   â”œâ”€â”€ articles.test.js
â”‚   â”œâ”€â”€ auth.test.js
â”‚   â””â”€â”€ comments.test.js
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ logger.js
â”œâ”€â”€ app.js
â”œâ”€â”€ hash.js
â”œâ”€â”€ package.json
â””â”€â”€ server.js


--- FILE CONTENTS ---
============================================================
FILE: config/db.js
============================================================
const mysql = require('mysql2/promise'); // â¬… this is important
require('dotenv').config();

const db = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASS,
  database: process.env.DB_NAME
});

module.exports = db;


============================================================
FILE: controllers/articleController.js
============================================================
const db = require('../config/db');
const jwt = require('jsonwebtoken');
require('dotenv').config();

// Helper to extract userId from token
const getUserIdFromToken = (token) => {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    return decoded.id;
  } catch (error) {
    throw new Error('Invalid token');
  }
}; // make sure this function is defined

exports.create = async (req, res) => {
  try {
    const { title, content, category, tags } = req.body;

    // Check token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(403).json({ message: 'Token missing' }); // ðŸ” changed 'error' to 'message'

    const userId = getUserIdFromToken(token);
    console.log('ðŸ”‘ Decoded User ID:', userId);
    // Validate input
    if (!title || !content || !category) {
      return res.status(400).json({ message: 'All fields are required' }); // ðŸ” here too
    }

    // Format tags as comma-separated string
    const formattedTags = Array.isArray(tags) ? tags.join(',') : tags;

    // Insert article
    const [result] = await db.query(
      'INSERT INTO articles (title, content, category, tags, user_id) VALUES (?, ?, ?, ?, ?)',
      [title, content, category, formattedTags, userId]
    );

    // Fetch inserted article
    const [article] = await db.query('SELECT * FROM articles WHERE id = ?', [result.insertId]);

    res.status(201).json(article[0]);
  } catch (error) {
    console.error('Create Error:', error.message);
    if (error.message === 'Invalid token') {
      res.status(403).json({ message: 'Unauthorized' }); // ðŸ” consistent key
    } else {
      res.status(500).json({ message: 'Internal Server Error' }); // ðŸ”
    }
  }
};


exports.getAll = async (req, res) => {
  try {
    const [articles] = await db.query('SELECT * FROM articles');
    res.status(200).json(articles);
  } catch (error) {
    console.error('GetAll Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};

exports.getById = async (req, res) => {
  try {
    const { id } = req.params;
    const [article] = await db.query('SELECT * FROM articles WHERE id = ?', [id]);

    if (article.length === 0) {
      return res.status(404).json({ error: 'Article not found' });
    }

    res.status(200).json(article[0]);
  } catch (error) {
    console.error('GetById Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};

exports.update = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, content, category, tags } = req.body;
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(403).json({ error: 'Token missing' });

    const userId = getUserIdFromToken(token);

    const formattedTags = Array.isArray(tags) ? tags.join(',') : tags;

    const [result] = await db.query(
      'UPDATE articles SET title = ?, content = ?, category = ?, tags = ? WHERE id = ? AND user_id = ?',
      [title, content, category, formattedTags, id, userId]
    );

    if (result.affectedRows === 0) {
      return res.status(404).json({ error: 'Article not found or not authorized' });
    }

    const [updated] = await db.query('SELECT * FROM articles WHERE id = ?', [id]);
    res.status(200).json(updated[0]);
  } catch (error) {
    console.error('Update Error:', error.message);
    if (error.message === 'Invalid token') {
      res.status(403).json({ error: 'Unauthorized' });
    } else {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};

exports.delete = async (req, res) => {
  try {
    const articleId = req.params.id;
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(403).json({ message: 'Token missing' });

    let userId;
    try {
      userId = getUserIdFromToken(token);
    } catch (err) {
      return res.status(403).json({ message: 'Invalid token' });
    }

    const [[user]] = await db.query('SELECT * FROM users WHERE id = ?', [userId]);
    if (!user) return res.status(403).json({ message: 'User not found' });

    const [[article]] = await db.query('SELECT * FROM articles WHERE id = ?', [articleId]);
    if (!article) return res.status(404).json({ message: 'Article not found' });

    // This is the key line
    if (user.id !== article.user_id && user.role !== 'admin') {
      return res.status(403).json({ message: 'Forbidden: not author or admin' }); // âœ… Fix: 403
    }

    await db.query('DELETE FROM articles WHERE id = ?', [articleId]);
    res.status(200).json({ message: 'Article deleted' });
  } catch (err) {
    console.error('Delete Error:', err.message);
    res.status(500).json({ message: 'Internal Server Error' });
  }
};

============================================================
FILE: controllers/authController.js
============================================================
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const db = require('../config/db');
require('dotenv').config();

exports.registerUser = async (req, res) => {
    const { username, email, password } = req.body;

    try {
        const hashedPassword = await bcrypt.hash(password, 10);

        const [existing] = await db.query(
            `SELECT * FROM users WHERE email = ? OR username = ?`,
            [email, username]
        );

        if (existing.length > 0)
            return res.status(400).json({ message: "User already exists" });

        await db.query(
            `INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)`,
            [username, email, hashedPassword]
        );

        res.status(201).json({ message: "User registered successfully" });
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

exports.loginUser = async (req, res) => {
    const { email, password } = req.body;

    try {
        const [users] = await db.query(
            `SELECT * FROM users WHERE email = ?`,
            [email]
        );

        if (users.length === 0)
            return res.status(404).json({ message: 'User Not Found' });

        const user = users[0];
        const isMatch = await bcrypt.compare(password, user.password_hash);

        if (!isMatch)
            return res.status(401).json({ message: 'Invalid Password' });

        const token = jwt.sign(
            { id: user.id, role: user.role },
            process.env.JWT_SECRET,
            { expiresIn: '1d' }
        );

        res.json({
            token,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                role: user.role
            }
        });
    } catch (err) {
        res.status(500).json({ message: 'Server Error', error: err.message });
    }
};


============================================================
FILE: controllers/commentController.js
============================================================
const db = require('../config/db');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const getUserFromToken = (authHeader) => {
  if (!authHeader) throw new Error('No token provided');
  const token = authHeader.split(' ')[1];
  return jwt.verify(token, process.env.JWT_SECRET);
};

// âœ… Add Comment
exports.addComment = async (req, res) => {
  try {
    const { content } = req.body;
    const articleId = req.params.id;
    const { id: userId } = getUserFromToken(req.headers.authorization);

    if (!content) return res.status(400).json({ error: 'Content is required' });

    const [result] = await db.query(
      'INSERT INTO comments (user_id, article_id, content) VALUES (?, ?, ?)',
      [userId, articleId, content]
    );

    const [comment] = await db.query('SELECT * FROM comments WHERE id = ?', [result.insertId]);
    res.status(201).json(comment[0]);
  } catch (err) {
    console.error('Add Comment Error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};

// âœ… Get Comments for an Article (with usernames)
exports.getCommentsByArticleId = async (req, res) => {
  try {
    const articleId = req.params.id;

    const [comments] = await db.query(
      `
      SELECT comments.*, users.username 
      FROM comments 
      JOIN users ON comments.user_id = users.id 
      WHERE comments.article_id = ?
      ORDER BY comments.created_at ASC
      `,
      [articleId]
    );

    res.status(200).json(comments);
  } catch (err) {
    console.error('Get Comments Error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};

// âœ… Delete Comment (owner or admin)
exports.deleteComment = async (req, res) => {
  try {
    const commentId = req.params.id;
    const { id: userId, role } = getUserFromToken(req.headers.authorization);

    let query = 'DELETE FROM comments WHERE id = ?';
    let values = [commentId];

    if (role !== 'admin') {
      query += ' AND user_id = ?';
      values.push(userId);
    }

    const [result] = await db.query(query, values);
    if (result.affectedRows === 0)
      return res.status(403).json({ error: 'Not authorized or comment not found' });

    res.json({ message: 'Comment deleted successfully' });
  } catch (err) {
    console.error('Delete Comment Error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};

// âœ… Edit Comment (only owner)
exports.editComment = async (req, res) => {
  try {
    const commentId = req.params.id;
    const { content } = req.body;
    const { id: userId } = getUserFromToken(req.headers.authorization);

    const [result] = await db.query(
      'UPDATE comments SET content = ? WHERE id = ? AND user_id = ?',
      [content, commentId, userId]
    );

    if (result.affectedRows === 0)
      return res.status(403).json({ error: 'Not authorized or comment not found' });

    const [updated] = await db.query('SELECT * FROM comments WHERE id = ?', [commentId]);
    res.json(updated[0]);
  } catch (err) {
    console.error('Edit Comment Error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};


============================================================
FILE: controllers/userController.js
============================================================
const db = require('../config/db');

exports.getUserProfile = async (req, res) => {
  try {
    const userId = req.params.id;

    // Fetch user
    const [users] = await db.query('SELECT id, username, email FROM users WHERE id = ?', [userId]);
    if (users.length === 0) return res.status(404).json({ error: 'User not found' });

    // Fetch articles
    const [articles] = await db.query('SELECT id, title, created_at FROM articles WHERE user_id = ?', [userId]);

    res.json({
      user: users[0],
      articles,
    });
  } catch (err) {
    console.error('User Profile Error:', err.message);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};


============================================================
FILE: middlewares/auth.js
============================================================
// âœ… auth.js
const jwt = require('jsonwebtoken');

exports.authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader?.split(' ')[1];

  if (!token) return res.status(401).json({ message: 'Access token missing' });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    return res.status(403).json({ message: 'Invalid token' });
  }
};


============================================================
FILE: middlewares/errorHandler.js
============================================================
const errorHandler = (err, req, res, next) => {
  console.error('Error:', err.message);

  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    error: err.message || 'Internal Server Error',
  });
};

module.exports = errorHandler;


============================================================
FILE: models/Article.js
============================================================
const db = require('../config/db');
const {v4:uuidv4} = require('uuid');

class Article {
    //create new article
    static async create({title,content,tags='',userId}){
        const [result] = await db.query(
            `INSERT INTO articles
            (title,content,tags,userId)
            VALUES(?,?,?,?) `, 
            [title,content,tags,userId]);

        return this.getById(result.insertId);
    }

    //get all articles
    static async getAll({tag,page=1,limit=10} = {}){
        let query =`SELECT articles.*,
        users.name AS author
        FROM articles
        LEFT JOIN users ON articles.user_id = users.id
        `;
        const params = [];
        if(tag){
            query += `WHERE tags LIKE ?`;
            params.push(`%${tag}%`);
        }
        //pagination
        query += `
        LIMIT ? OFFSET ?
        `;
        params.push(limit,(page-1)*limit);
        const [article] = await db.query(query,params);
        return article;
    }
    static async getById(id) {
        const [[article]] = await db.query(
        `SELECT 
        articles.*, 
        users.username AS author 
        FROM articles 
        LEFT JOIN users ON articles.user_id = users.id 
        WHERE articles.id = ?`,
      [id]
    );
    return article || null;
    }
    static async update(id,{title,content,tags,userId}){
        await db.query(`
            UPDATE articles
            SET title = ?, content = ?, tags = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE id = ? AND user_id = ?`,
            [title, content, tags, id, userId]
        );
    }
    static async delete(id,userId){
        const [result] = await db.query(`DELETE FROM articles 
       WHERE id = ? AND user_id = ?`,[id,userId]);
       return result.affectedRows > 0;
    }
    static async getByUser(userId){
        const [articles] = await db.query(
            `SELECT * FROM articles WHERE user_id = ?`,
            [userId]
        );
        return articles || null;
    }
}

module.exports = Article;

============================================================
FILE: routes/articleRoutes.js
============================================================
const express = require('express');
const router = express.Router();

// â›ï¸ Fix: Destructure the named export correctly
const { authenticateToken } = require('../middlewares/auth');

const {
  create,
  getAll,
  getById,
  update,
  delete: deleteArticle
} = require('../controllers/articleController');

const { addComment } = require('../controllers/commentController');

// ðŸ§  CRUD + Comment route with proper auth middleware
router.post('/articles', authenticateToken, create);
router.get('/articles', getAll);
router.get('/articles/:id', getById);
router.put('/articles/:id', authenticateToken, update);
router.delete('/articles/:id', authenticateToken, deleteArticle);
router.post('/articles/:id/comments', authenticateToken, addComment);

module.exports = router;


============================================================
FILE: routes/authRoutes.js
============================================================
const express = require('express');
const router = express.Router();
const {registerUser,loginUser
} = require('../controllers/authController');
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 5,
  message: { error: 'Too many login attempts. Please try again later.' },
  standardHeaders: true,
  legacyHeaders: false,
});

router.post('/register',registerUser);
router.post('/login',loginUser);

module.exports = router;


============================================================
FILE: routes/commentRoutes.js
============================================================
const express = require('express');
const router = express.Router();
const {
  addComment,
  getCommentsByArticleId,
  deleteComment,
  editComment
} = require('../controllers/commentController');

// Comment routes
router.post('/articles/:id/comments', addComment);
router.get('/articles/:id/comments', getCommentsByArticleId);
router.delete('/comments/:id', deleteComment);
router.put('/comments/:id', editComment);

module.exports = router;


============================================================
FILE: routes/userRoutes.js
============================================================
const express = require('express');
const router = express.Router();
const { getUserProfile   } = require('../controllers/userController.js');
const {authenticateToken} = require('../middlewares/auth.js');

router.get('/:id/profile', authenticateToken, getUserProfile);

module.exports = router;

============================================================
FILE: tests/middleware/authMiddleware.test.js
============================================================
const jwt = require('jsonwebtoken');
const { authenticateToken } = require('../../middlewares/auth');
require('dotenv').config();

describe('authenticateToken Middleware', () => {
  const mockUser = { id: 1, email: 'test@example.com', role: 'user' };
  const secret = process.env.JWT_SECRET || 'your_secret_key';

  const getMockReqResNext = (token) => {
    const req = {
      headers: { authorization: `Bearer ${token}` },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const next = jest.fn();
    return { req, res, next };
  };

  it('should call next() if token is valid', () => {
    const token = jwt.sign(mockUser, secret);
    const { req, res, next } = getMockReqResNext(token);
    authenticateToken(req, res, next);
    expect(req.user).toEqual(expect.objectContaining({ id: mockUser.id }));
    expect(next).toHaveBeenCalled();
  });

  it('should return 401 if token is missing', () => {
    const req = { headers: {} };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const next = jest.fn();

    authenticateToken(req, res, next);
    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({ message: 'Access token missing' });
    expect(next).not.toHaveBeenCalled();
  });

  it('should return 403 if token is invalid', () => {
    const { req, res, next } = getMockReqResNext('invalid.token.here');
    authenticateToken(req, res, next);
    expect(res.status).toHaveBeenCalledWith(403);
    expect(res.json).toHaveBeenCalledWith({ message: 'Invalid token' });
    expect(next).not.toHaveBeenCalled();
  });
});


============================================================
FILE: tests/utils/setup.js
============================================================
const db = require('../../config/db');

module.exports = async () => {
  // Clean or reset your test database
  await db.query('DELETE FROM comments');
  await db.query('DELETE FROM articles');
  await db.query('DELETE FROM users');
};


============================================================
FILE: tests/utils/testLoginHelper.js
============================================================
const jwt = require('jsonwebtoken');

const generateTestToken = (user = { id: 1, email: 'user@test.com', role: 'user' }) => {
  const secret = process.env.JWT_SECRET || 'your_secret_key';
  const token = jwt.sign(user, secret);
  return { token, user };
};

module.exports = { generateTestToken };


============================================================
FILE: tests/utils/testUtils.js
============================================================
const jwt = require('jsonwebtoken');

const generateToken = (user) => {
  return jwt.sign(user, process.env.JWT_SECRET || 'your_jwt_secret', {
    expiresIn: '1d',
  });
};

// Simulate a logged-in user (regular user by default)
const mockUser = {
  id: 1,
  username: 'testuser',
  email: 'test@example.com',
  role: 'user',
};

const mockAdmin = {
  id: 2,
  username: 'admin',
  email: 'admin@example.com',
  role: 'admin',
};

const getAuthHeader = (user = mockUser) => {
  const token = generateToken(user);
  return { Authorization: `Bearer ${token}` };
};

module.exports = {
  generateToken,
  mockUser,
  mockAdmin,
  getAuthHeader,
};


============================================================
FILE: tests/articles.test.js
============================================================
const request = require('supertest');
const app = require('../app');
const db = require('../config/db');
const setup  = require('./utils/setup'); // âœ… clear DB, add seed data
const { generateTestToken } = require('./utils/testLoginHelper');

let token;
let user;

beforeEach(async () => {
  await setup();

  const author = {
    username: 'author1',
    email: 'author@example.com',
    password: 'pass123',
  };

  await request(app).post('/api/auth/register').send(author);

  const res = await request(app).post('/api/auth/login').send({
    email: author.email,
    password: author.password,
  });

  token = res.body.token;
  // âœ… Outsider user
  const outsider = {
    username: 'outsider',
    email: 'outsider@example.com',
    password: 'pass456',
  };

  await request(app).post('/api/auth/register').send(outsider);

  const outsiderRes = await request(app).post('/api/auth/login').send({
    email: outsider.email,
    password: outsider.password,
  });

  outsiderToken = outsiderRes.body.token;
});

afterAll(async () => {
  await db.end();
});

describe('Articles API', () => {
  test('Should create a new article', async () => {
    const res = await request(app)
      .post('/api/articles')
      .set('Authorization', `Bearer ${token}`)
      .send({
        title: 'Test Article',
        content: 'Content goes here',
        category: 'tech',
        tags: 'react,node',
      });

    expect(res.statusCode).toBe(201);
    expect(res.body.title).toBe('Test Article');
    expect(res.body.content).toBe('Content goes here');
    expect(res.body.category).toBe('tech');
  });

  test('Should fail to create article with missing fields', async () => {
    const res = await request(app)
      .post('/api/articles')
      .set('Authorization', `Bearer ${token}`)
      .send({ title: '', content: '' });

    expect(res.statusCode).toBe(400);
    expect(res.body.message).toMatch(/required/i);
  });

  test('Should get all articles', async () => {
    const res = await request(app).get('/api/articles');
    expect(res.statusCode).toBe(200);
    expect(Array.isArray(res.body)).toBe(true);
  });

  test('Should not delete an article if user is not owner or admin', async () => {
    // First create an article
    const postRes = await request(app)
      .post('/api/articles')
      .set('Authorization', `Bearer ${token}`)
      .send({
        title: 'Another Article',
        content: 'Secret content',
        category: 'science',
        tags: 'test',
      });

    const articleId = postRes.body.id;

    // Generate token for a different user (not the article owner)
    const outsiderToken = generateTestToken({
      id: 999,
      email: 'outsider@example.com',
      role: 'user',
    }).token;

    // Try to delete it with another user
    const deleteRes = await request(app)
      .delete(`/api/articles/${articleId}`)
      .set('Authorization', `Bearer ${outsiderToken}`);

    expect(deleteRes.statusCode).toBe(403);
    expect(deleteRes.body.message).toMatch("User not found");
  });
});


============================================================
FILE: tests/auth.test.js
============================================================
const request = require('supertest');
const app = require('../app');
const db = require('../config/db');
const setup = require('./utils/setup');

beforeEach(async () => {
  await setup();
});

afterAll(async () => {
  await db.end();
});

describe('Auth API', () => {
  const user = {
    username: 'testuser',
    email: 'test@example.com',
    password: 'test123'
  };

  test('Should register a new user', async () => {
    const res = await request(app).post('/api/auth/register').send(user);

    expect(res.statusCode).toBe(201);
    expect(res.body.message).toBe('User registered successfully');
  });

  test('Should login with correct credentials', async () => {
    await request(app).post('/api/auth/register').send(user);

    const res = await request(app).post('/api/auth/login').send({
      email: user.email,
      password: user.password
    });

    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('token');
    expect(res.body.user.email).toBe(user.email);
  });

  test('Should fail login with wrong password', async () => {
    await request(app).post('/api/auth/register').send(user);

    const res = await request(app).post('/api/auth/login').send({
      email: user.email,
      password: 'wrongpass'
    });

    expect(res.statusCode).toBe(401);
    expect(res.body.message).toBe('Invalid credentials');
  });
});


============================================================
FILE: tests/comments.test.js
============================================================
const request = require('supertest');
const app = require('../app');
const db = require('../config/db');
const setup = require('./utils/setup');

let token, articleId;

beforeEach(async () => {
  await setup();

  const user = {
    username: 'commenter',
    email: 'comm@example.com',
    password: 'pass123'
  };

  await request(app).post('/api/auth/register').send(user);

  const res = await request(app).post('/api/auth/login').send({
    email: user.email,
    password: user.password
  });

  token = res.body.token;

  const article = await request(app)
    .post('/api/articles')
    .set('Authorization', `Bearer ${token}`)
    .send({
      title: 'Article with Comments',
      content: 'Great article',
      category: 'general',
      tags: 'blog,test'
    });

  articleId = article.body.id;
});

afterAll(async () => {
  await db.end();
});

describe('Comments API', () => {
  test('Should add a comment to an article', async () => {
    const res = await request(app)
      .post(`/api/articles/${articleId}/comments`)
      .set('Authorization', `Bearer ${token}`)
      .send({ content: 'This is a comment' });

    expect(res.statusCode).toBe(201);
    expect(res.body.message).toBe('Comment added');
  });

  test('Should fetch comments for an article', async () => {
    await request(app)
      .post(`/api/articles/${articleId}/comments`)
      .set('Authorization', `Bearer ${token}`)
      .send({ content: 'Nice one!' });

    const res = await request(app).get(`/api/articles/${articleId}/comments`);
    expect(res.statusCode).toBe(200);
    expect(Array.isArray(res.body)).toBe(true);
  });
});


============================================================
FILE: app.js
============================================================
const express = require('express');
const cors = require('cors');
const app = express();

require('dotenv').config();

// Allow requests from frontend (adjust the origin if needed)
app.use(cors({
  origin: 'http://localhost:3000',
  credentials: true
}));

app.use(express.json());

// Your routes here
const authRoutes = require('./routes/authRoutes');
const articleRoutes = require('./routes/articleRoutes');
const commentRoutes = require('./routes/commentRoutes');
const userRoutes = require('./routes/userRoutes');

app.use('/api/auth', authRoutes);
app.use('/api', articleRoutes);
app.use('/api', commentRoutes); // if you're using /comments
app.use('/api', userRoutes); // if you're using /users

module.exports = app;


============================================================
FILE: hash.js
============================================================
const bcrypt = require('bcryptjs');
bcrypt.hash('admin123', 10).then(console.log);

============================================================
FILE: package.json
============================================================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "test": "cross-env NODE_ENV=test jest --runInBand --detectOpenHandles",
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "bcryptjs": "^3.0.2",
    "body-parser": "^2.2.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "jsonwebtoken": "^9.0.2",
    "mysql2": "^3.14.3",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "cross-env": "^10.0.0",
    "jest": "^30.0.5",
    "nodemon": "^3.1.10",
    "supertest": "^7.1.4"
  }
}


============================================================
FILE: server.js
============================================================
const app = require('./app');
const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});